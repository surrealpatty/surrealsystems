<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Profile - CodeCrowds (Diag)</title>
<link rel="stylesheet" href="profile.css" />

<style>
  .hidden{display:none}
  .spinner{display:inline-block}
  .muted{color:#666}
  .card{background:#fff;border-radius:12px;padding:16px;box-shadow:0 8px 20px rgba(0,0,0,.06);margin-bottom:12px}
  .floating-btn{position:fixed;right:16px;bottom:16px;border-radius:999px;padding:10px 14px}
  /* diagnostic banner */
  #diagBanner {
    position: fixed; top: 0; left: 0; right: 0;
    background: #b91c1c; color: #fff; padding: 10px 14px;
    font: 500 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    z-index: 999999;
  }
  #diagBanner .muted { color: #ffe2e2; }
  body { padding-top: 0; }
</style>

<!-- IMPORTANT: expose API_URL early -->
<script>window.API_URL = '/api';</script>
<!-- Load your helpers (if present). If this 404s, the fallback below covers it. -->
<script src="script.js" defer></script>
</head>
<body>
  <div id="diagBanner" class="hidden"></div>

  <main class="container">
    <header>
      <h1 id="profile-username"><span class="spinner"></span> Loading username...</h1>
      <p id="profile-description"><span class="spinner"></span> Loading description...</p>
      <div id="descControls" class="hidden">
        <button type="button" id="editDescBtn">Edit Description</button>
      </div>
    </header>

    <section>
      <h2>User's Services</h2>
      <p class="section-subtle">These also appear on the Services page.</p>
      <div id="services-list"><p><span class="spinner"></span> Loading services...</p></div>

      <div class="row row-center row-gap-8 justify-center">
        <button type="button" id="loadMoreServicesBtn" class="hidden">Load more</button>
      </div>

      <div id="newServiceSection" class="new-service hidden">
        <input type="text" id="newServiceTitle" placeholder="Service Title" />
        <textarea id="newServiceDesc" placeholder="Service Description"></textarea>
        <input type="number" id="newServicePrice" placeholder="Price in USD" />
        <button type="button" id="createServiceBtn">Create Service</button>
      </div>
    </section>

    <section>
      <h2>Ratings & Reviews</h2>
      <div id="ratings-summary" class="card">
        <p><strong><span id="avg-stars">0.0</span> / 5.0</strong> • <span id="ratings-count">0</span> ratings</p>
      </div>

      <div id="rate-form" class="card hidden" aria-labelledby="rateFormTitle">
        <h3 id="rateFormTitle">Leave a rating</h3>
        <div class="row row-center row-gap-8">
          <label for="rateStars">Stars</label>
          <select id="rateStars" title="Select stars">
            <option value="5">5</option><option value="4">4</option>
            <option value="3">3</option><option value="2">2</option>
            <option value="1">1</option>
          </select>
        </div>
        <textarea id="rateComment" class="w-full" placeholder="Say something helpful (optional)" rows="3"></textarea>
        <button type="button" id="submitRatingBtn">Submit Rating</button>
        <p id="rateMsg" class="muted"></p>
        <div id="rateUpgradeHint" class="hidden muted">
          Rating is a paid feature.
          <button type="button" id="upgradeInlineBtn" class="upgrade-btn">Upgrade to Paid</button>
        </div>
      </div>

      <div id="ratings-list" class="review-list">
        <p><span class="spinner"></span> Loading ratings...</p>
      </div>
    </section>

    <div class="row row-center row-gap-8 justify-center">
      <button type="button" id="logoutBtn" class="logout-btn">Logout</button>
      <button type="button" id="upgradeBtn" class="upgrade-btn hidden">Upgrade to Paid</button>
    </div>
  </main>

  <!-- Floating shortcuts (only on your own profile) -->
  <button type="button" class="floating-btn hidden" id="goToServicesBtn">Services</button>
  <button type="button" class="floating-btn hidden" id="goToMessagesBtn">Messages</button>
  <button type="button" class="floating-btn hidden" id="addNewServiceBtn">+ Service</button>
  <button type="button" class="floating-btn hidden" id="editDescBtnFloat">Edit Bio</button>

  <!-- Back to my profile (visible only when viewing someone else) -->
  <button type="button" class="floating-btn hidden" id="backToMyProfileBtn">← My Profile</button>

  <nav class="mobile-button-row hidden" id="mobileRow" aria-label="Mobile actions">
    <button type="button" id="mobileServicesBtn">Services</button>
    <button type="button" id="mobileMessagesBtn">Messages</button>
    <button type="button" id="mobileAddServiceBtn">+ Service</button>
    <button type="button" id="mobileBackBtn" class="hidden">My Profile</button>
  </nav>

<script>
/* -------------------- DIAGNOSTIC + FALLBACK LAYER -------------------- */
const Diag = {
  show(msg){
    const el = document.getElementById('diagBanner');
    el.innerHTML = msg;
    el.classList.remove('hidden');
    console.error('[Diag]', el.textContent.replace(/\s+/g,' ').trim());
  },
  hide(){ document.getElementById('diagBanner').classList.add('hidden'); }
};

// Fallbacks if script.js is missing or broken
function safe(fn, fallback){
  try { return typeof fn === 'function' ? fn : fallback; } catch { return fallback; }
}
const getToken = safe(window.getToken, ()=> localStorage.getItem('token'));
const getUserId = safe(window.getUserId, ()=> localStorage.getItem('userId'));
const setUserId = safe(window.setUserId, (v)=> localStorage.setItem('userId', v));
const getDisplayName = safe(window.getDisplayName, (u)=> u?.username || u?.name || 'User');
const getDescription = safe(window.getDescription, (u)=> u?.description || '');
let apiFetch = window.apiFetch;

// Harden apiFetch if missing
if (typeof apiFetch !== 'function') {
  apiFetch = async function apiFetch(url, opts={}){
    const token = getToken();
    const headers = {
      'Content-Type': 'application/json',
      ...(token ? { 'Authorization': `Bearer ${token}` } : {})
    };
    const init = {
      method: opts.method || 'GET',
      headers,
      body: opts.body ? JSON.stringify(opts.body) : undefined,
      signal: opts.signal
    };
    const full = url.startsWith('http') ? url : (url.startsWith('/') ? url : `${API_URL.replace(/\/$/,'')}/${url.replace(/^\//,'')}`);
    const res = await fetch(full, init);
    if (!res.ok) {
      const text = await res.text().catch(()=> '');
      throw new Error(`apiFetch ${res.status} ${res.statusText}: ${text || 'No body'}`);
    }
    const ct = res.headers.get('content-type') || '';
    return ct.includes('application/json') ? res.json() : res.text();
  }
}

/* -------------------------- SAFE LOGIN GUARD -------------------------- */
// Do NOT run this early in <head>; do it here so helpers exist.
(async function guard(){
  try {
    if (typeof window.isLoggedIn === 'function') {
      // if helper exists, use it
      if (!isLoggedIn()) {
        const here = location.pathname + location.search;
        location.replace(`/?from=${encodeURIComponent(here)}`);
        return;
      }
    } else {
      // Fall back: token presence only; if no token, show banner (don’t loop)
      const token = getToken();
      if (!token) {
        Diag.show('You appear to be logged out. <span class="muted">No token found. UI will load, but protected API calls will fail.</span>');
      }
    }
  } catch (e) {
    Diag.show('Login guard error. <span class="muted">Check <code>isLoggedIn()</code> or <code>script.js</code>.</span>');
  }
})();

/* -------------------- PERF HELPERS: SWR cache + timeout -------------------- */
const SWR_TTL_MS = 60_000; // 60s
function lsGet(key){ try { return JSON.parse(localStorage.getItem(key) || 'null'); } catch { return null; } }
function lsSet(key, val){ try { localStorage.setItem(key, JSON.stringify(val)); } catch {} }
function isFresh(ts){ return (Date.now() - (ts||0)) < SWR_TTL_MS; }
async function fetchWithTimeout(url, opts={}, ms=8000){
  const timeoutCtrl = new AbortController();
  const timer = setTimeout(() => timeoutCtrl.abort(), ms);
  const external = opts.signal;
  const ctrl = external ? new AbortController() : timeoutCtrl;
  if (external) external.addEventListener('abort', ()=> ctrl.abort(), { once: true });
  try { return await apiFetch(url, { ...opts, signal: ctrl.signal }); }
  finally { clearTimeout(timer); }
}

/* -------------------------- INSTANT USER PAINT -------------------------- */
try {
  const cached = JSON.parse(localStorage.getItem('cc_me') || 'null');
  if (cached) {
    const cachedName = getDisplayName(cached);
    if (cachedName) document.getElementById('profile-username').textContent = cachedName;
    const cachedDesc = getDescription(cached);
    if (cachedDesc) document.getElementById('profile-description').textContent = cachedDesc;

    const params = new URLSearchParams(location.search);
    if (cached.id && !params.get('userId')) showOwnerUI(true);
  }
} catch {}

/* ------------------------------ DOM refs ------------------------------ */
const profileUsername = document.getElementById('profile-username');
const profileDescription = document.getElementById('profile-description');
const descControls = document.getElementById('descControls');
const editDescBtn = document.getElementById('editDescBtn');

const servicesList = document.getElementById('services-list');
const newServiceSection = document.getElementById('newServiceSection');
const newServiceTitle = document.getElementById('newServiceTitle');
const newServiceDesc = document.getElementById('newServiceDesc');
const newServicePrice = document.getElementById('newServicePrice');
const createServiceBtn = document.getElementById('createServiceBtn');

const goToServicesBtn = document.getElementById('goToServicesBtn');
const goToMessagesBtn = document.getElementById('goToMessagesBtn');
const addNewServiceBtn = document.getElementById('addNewServiceBtn');
const editDescBtnFloat = document.getElementById('editDescBtnFloat');
const mobileServicesBtn = document.getElementById('mobileServicesBtn');
const mobileMessagesBtn = document.getElementById('mobileMessagesBtn');
const mobileAddServiceBtn = document.getElementById('mobileAddServiceBtn');
const mobileRow = document.getElementById('mobileRow');
const mobileBackBtn = document.getElementById('mobileBackBtn');

const ratingsList = document.getElementById('ratings-list');
const avgStarsEl = document.getElementById('avg-stars');
const ratingsCountEl = document.getElementById('ratings-count');
const rateForm = document.getElementById('rate-form');

// Rating form controls
const rateStars = document.getElementById('rateStars');
const rateComment = document.getElementById('rateComment');
const submitRatingBtn = document.getElementById('submitRatingBtn');
const rateMsg = document.getElementById('rateMsg');
const rateUpgradeHint = document.getElementById('rateUpgradeHint');
const upgradeInlineBtn = document.getElementById('upgradeInlineBtn');

const logoutBtn = document.getElementById('logoutBtn');
const upgradeBtn = document.getElementById('upgradeBtn');
const backToMyProfileBtn = document.getElementById('backToMyProfileBtn');
const loadMoreBtn = document.getElementById('loadMoreServicesBtn');

/* ------------------------------ State ------------------------------ */
let currentUserTier = 'free';
let currentProfileUserId = null; // <- which profile we're viewing (for rating)
let svcPage = 1, svcLoading = false;
let svcAborter = null, ratingsAborter = null;

/* ------------------------------ Utils ------------------------------ */
function esc(s){ return String(s ?? '').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function showOwnerUI(isOwner){
  [goToServicesBtn,goToMessagesBtn,addNewServiceBtn,editDescBtnFloat,mobileRow,descControls]
    .forEach(el=>el.classList.toggle('hidden',!isOwner));
  backToMyProfileBtn.classList.toggle('hidden',isOwner);
  mobileBackBtn.classList.toggle('hidden',isOwner);
  if (!isOwner) { newServiceSection.classList.add('hidden'); newServiceSection.classList.remove('show-flex'); }
}

/* ----------------------------- API PINGS ----------------------------- */
(async function healthCheck(){
  try{
    const h = await fetchWithTimeout('health', {}, 4000); // GET /api/health (string or json)
    console.log('[health]', h);
  }catch(e){
    Diag.show('API health check failed. <span class="muted">Verify that <code>/api/health</code> is reachable, check CORS, and confirm the server is running.</span>');
  }
})();

/* ---------------------------- Data loaders ---------------------------- */
async function fetchMe() {
  try{
    const me = await fetchWithTimeout('users/me', {}, 8000); // -> { user }
    const u = me?.user || me || {};
    if (!getUserId() && u.id) setUserId(String(u.id));
    try {
      localStorage.setItem('cc_me', JSON.stringify(u));
      const dn = getDisplayName(u);
      if (dn) localStorage.setItem('username', dn);
    } catch {}
    currentUserTier = u.tier || 'free';
    return u;
  }catch(e){
    Diag.show('Failed to load user profile. <span class="muted">Check auth token and <code>/api/users/me</code>.</span>');
    throw e;
  }
}

async function loadProfile() {
  try {
    const me = await fetchMe();
    const loggedInUserId = getUserId();

    const params = new URLSearchParams(location.search);
    const qsUserId = params.get('userId');
    const profileUserId = (qsUserId || loggedInUserId)?.toString();

    // Keep the submit handler aware of which profile we're viewing
    currentProfileUserId = profileUserId;

    const data = qsUserId ? await fetchWithTimeout(`users/${profileUserId}`, {}, 8000) : { user: me };
    const u = data.user || data || {};

    profileUsername.textContent = getDisplayName(u) || 'User';
    profileDescription.textContent = getDescription(u) || 'No description yet.';

    const viewingSelf = profileUserId === loggedInUserId;
    showOwnerUI(viewingSelf);

    const canRate = (!viewingSelf && currentUserTier === 'paid');
    rateForm.classList.toggle('hidden', !canRate);

    // hide inline upgrade hint by default
    if (rateUpgradeHint) rateUpgradeHint.classList.add('hidden');

    if (viewingSelf && currentUserTier === 'free') upgradeBtn.classList.remove('hidden');
    else upgradeBtn.classList.add('hidden');

    await loadServices({ reset: true, userId: profileUserId });
    (window.requestIdleCallback ? requestIdleCallback : (cb)=>setTimeout(cb,0))(()=> loadRatings(profileUserId));
  } catch (err) {
    console.error('Profile load error:', err);
  }
}

/* ----------------------------- Services SWR ----------------------------- */
function serviceCardHTML(s,isOwner){
  return `<div class="card">
    <h3>${esc(s.title)}</h3>
    <p>${esc(s.description)}</p>
    <p><strong>Price:</strong> $${Number(s.price).toLocaleString(undefined,{maximumFractionDigits:2})}</p>
    <div class="service-buttons ${isOwner ? '' : 'hidden'}">
      <button class="edit-service-btn" data-id="${s.id}">Edit</button>
      <button class="delete-service-btn" data-id="${s.id}">Delete</button>
    </div>
  </div>`;
}
function renderServicesHTML(list, loggedInUserId){
  if (!list?.length) return '';
  let out = '';
  for (const s of list){
    const isOwner = loggedInUserId === (s.user?.id?.toString() || s.userId?.toString() || '');
    out += serviceCardHTML(s, isOwner);
  }
  return out;
}

async function loadServices({reset=false, userId} = {}) {
  if (svcLoading) return; svcLoading = true;
  try{
    const loggedInUserId = getUserId();
    const cacheKey = `cc_services_${userId || 'me'}_p${svcPage}`;

    if (reset){
      svcPage=1;
      const cached = lsGet(cacheKey);
      if (cached && isFresh(cached.ts) && Array.isArray(cached.items) && cached.items.length){
        servicesList.innerHTML = renderServicesHTML(cached.items, loggedInUserId);
        loadMoreBtn.classList.toggle('hidden', !cached.hasMore);
      } else {
        servicesList.innerHTML = Array.from({length:3}).map(()=>`
          <div class="card fade-in">
            <h3 style="background:#eee;height:18px;width:60%;border-radius:6px;"></h3>
            <p style="background:#f2f2f2;height:14px;width:100%;border-radius:6px;"></p>
            <p style="background:#f2f2f2;height:14px;width:80%;border-radius:6px;"></p>
          </div>
        `).join('');
        loadMoreBtn.classList.add('hidden');
      }
    }

    const url = new URL(`${API_URL}/services`, location.origin);
    if (userId) url.searchParams.set('userId', userId);
    url.searchParams.set('limit', svcPage === 1 ? '6' : '12');
    url.searchParams.set('page', String(svcPage));

    if (svcAborter) { try { svcAborter.abort(); } catch {} }
    svcAborter = new AbortController();

    const data = await fetchWithTimeout(url.pathname + url.search, { signal: svcAborter.signal }, 8000);
    const list = data.services || [];
    const hasMore = !!data.hasMore;

    lsSet(cacheKey, { ts: Date.now(), items: list, hasMore });

    const html = renderServicesHTML(list, loggedInUserId);
    if (reset) servicesList.innerHTML = html;
    else servicesList.insertAdjacentHTML('beforeend', html);

    loadMoreBtn.classList.toggle('hidden', !hasMore);
    if (hasMore) svcPage += 1;

    if (!list.length && svcPage===2 && reset){
      servicesList.innerHTML = '<div class="card"><h3>No Services Yet</h3><p class="muted">Nothing posted yet.</p></div>';
      loadMoreBtn.classList.add('hidden');
    }
  }catch(err){
    if (err?.name !== 'AbortError') {
      Diag.show('Failed to load services. <span class="muted">Check <code>/api/services</code> and server logs.</span>');
      console.error(err);
      if (svcPage===1) servicesList.innerHTML='<p>Failed to load services.</p>';
    }
  }finally{ svcLoading=false; }
}
loadMoreBtn.addEventListener('click', ()=> loadServices({ reset:false }));

/* ----------------------------- Ratings SWR ----------------------------- */
function renderStars(n){ const r=Math.round(n); return '★'.repeat(r)+'☆'.repeat(5-r); }
async function loadRatings(userId){
  const cacheKey = `cc_ratings_${userId}`;
  const cached = lsGet(cacheKey);
  if (cached && isFresh(cached.ts) && Array.isArray(cached.ratings)){
    paintRatings(cached.summary || { average: 0, count: 0 }, cached.ratings);
  } else {
    ratingsList.innerHTML='<p><span class="spinner"></span> Loading ratings...</p>';
  }

  if (ratingsAborter) { try { ratingsAborter.abort(); } catch {} }
  ratingsAborter = new AbortController();
  try{
    const data = await fetchWithTimeout(`ratings/user/${userId}`, { signal: ratingsAborter.signal }, 8000);
    const summary = { average: data.summary?.average ?? 0, count: data.summary?.count ?? 0 };
    const ratings = data.ratings || [];
    lsSet(cacheKey, { ts: Date.now(), summary, ratings });
    paintRatings(summary, ratings);
  }catch(err){
    if (err?.name !== 'AbortError') {
      console.error(err);
      if (!cached) ratingsList.innerHTML = '<p class="muted">Failed to load ratings.</p>';
    }
  }
}
function paintRatings(summary, ratings){
  avgStarsEl.textContent = Number(summary.average || 0).toFixed(1);
  ratingsCountEl.textContent = summary.count || 0;
  if (!ratings?.length){
    ratingsList.innerHTML = '<p class="muted">No ratings yet.</p>';
    return;
  }
  let html = '';
  for (const r of ratings){
    html += `<div class="review">
      <div class="meta-row">
        <strong>${esc(r.rater?.username || ('User '+r.raterId))}</strong>
        <span class="stars">${renderStars(r.stars)}</span>
        <span class="badge">${Number(r.stars).toFixed(1)}</span>
        <span class="muted">${new Date(r.createdAt).toLocaleString()}</span>
      </div>
      ${r.comment ? `<p>${esc(r.comment)}</p>` : '<p class="muted">No comment</p>'}
    </div>`;
  }
  ratingsList.innerHTML = html;
}

/* ----------------------------- Edit / Nav ----------------------------- */
let editingDesc=false;
function toggleDescEdit(force){
  editingDesc = typeof force==='boolean' ? force : !editingDesc;
  profileDescription.contentEditable = editingDesc;
  editDescBtn.textContent = editingDesc ? 'Save Description' : 'Edit Description';
  if (editingDesc) profileDescription.focus(); else profileDescription.blur();
}
async function saveDescription(){
  const newDesc = profileDescription.textContent.trim();
  try{
    const out = await fetchWithTimeout('users/me/description', { method:'PUT', body:{ description: newDesc } }, 8000);
    const saved = out?.user || {};
    profileDescription.textContent = getDescription(saved) || newDesc;
  }catch(err){ alert('Failed to save description'); console.error(err); }
  finally{ toggleDescEdit(false); }
}
editDescBtn.addEventListener('click', ()=> !editingDesc ? toggleDescEdit(true) : saveDescription());
document.getElementById('editDescBtnFloat').addEventListener('click', ()=> !editingDesc ? toggleDescEdit(true) : saveDescription());

document.getElementById('goToServicesBtn').addEventListener('click', ()=> location.href='services.html');
document.getElementById('goToMessagesBtn').addEventListener('click', ()=> location.href='messages.html');
document.getElementById('mobileServicesBtn').addEventListener('click', ()=> location.href='services.html');
document.getElementById('mobileMessagesBtn').addEventListener('click', ()=> location.href='messages.html');

document.getElementById('logoutBtn').addEventListener('click', ()=>{
  localStorage.clear(); location.replace('/');
});
document.getElementById('upgradeBtn').addEventListener('click', async ()=>{
  try{
    if (!confirm('Upgrade to a paid account?')) return;
    await fetchWithTimeout('users/me/upgrade', { method:'PUT' }, 8000);
    alert('Upgraded successfully!'); currentUserTier = 'paid'; await loadProfile();
  }catch(err){ alert(err.message || 'Upgrade failed'); }
});

/* ----------------------+Service open + create ---------------------- */
function openNewService() {
  newServiceSection.classList.remove('hidden');
  newServiceSection.classList.add('show-flex');
  newServiceTitle.focus();
  try { newServiceSection.scrollIntoView({ behavior: 'smooth', block: 'center' }); } catch {}
}
addNewServiceBtn.addEventListener('click', openNewService);
mobileAddServiceBtn.addEventListener('click', openNewService);

async function createService() {
  const title = newServiceTitle.value.trim();
  const description = newServiceDesc.value.trim();
  const price = Number(newServicePrice.value);
  if (!title) { alert('Title is required'); return; }
  if (Number.isNaN(price) || price < 0) { alert('Enter a valid price'); return; }

  try {
    await fetchWithTimeout('services', { method: 'POST', body: { title, description, price } }, 8000);
    newServiceTitle.value = ''; newServiceDesc.value = ''; newServicePrice.value = '';
    await loadServices({ reset: true, userId: getUserId() });
  } catch (err) {
    console.error(err); alert('Failed to create service');
  }
}
createServiceBtn.addEventListener('click', createService);

/* ------------------------- Rating submit handlers --------------------- */

// small helper to show a transient message in the rating area
function showRateMsg(txt, isError=false){
  if (!rateMsg) return;
  rateMsg.textContent = txt || '';
  rateMsg.style.color = isError ? '#b91c1c' : '#2b7a2b';
  if (!txt) return;
  setTimeout(()=> { if (rateMsg) rateMsg.textContent = ''; }, 4500);
}

if (submitRatingBtn) {
  submitRatingBtn.addEventListener('click', async () => {
    const stars = parseInt((rateStars?.value || '0'), 10) || 0;
    const comment = (rateComment?.value || '').trim();
    const rateeId = currentProfileUserId || (new URLSearchParams(location.search)).get('userId') || getUserId();

    if (!rateeId) { showRateMsg('No target user to rate', true); return; }
    if (!stars || stars < 1 || stars > 5) { showRateMsg('Please pick 1–5 stars', true); return; }

    submitRatingBtn.disabled = true;
    showRateMsg('Submitting…');

    try {
      const payload = { rateeId, stars, comment: comment || null };
      // POST /api/ratings (apiFetch / fetchWithTimeout will prefix API_URL)
      const out = await fetchWithTimeout('ratings', { method: 'POST', body: payload }, 8000);

      showRateMsg(out?.message || 'Rating saved');
      // refresh summary + ratings list
      await loadRatings(rateeId);

      // clear comment optionally
      if (rateComment) rateComment.value = '';
      if (rateUpgradeHint) rateUpgradeHint.classList.add('hidden');

    } catch (err) {
      console.error('Rating submit error', err);
      const m = String(err?.message || '');
      // detect upgrade requirement (server returns 403 / message about upgrade)
      if (m.includes('403') || m.toLowerCase().includes('upgrade')) {
        if (rateUpgradeHint) rateUpgradeHint.classList.remove('hidden');
        showRateMsg('Upgrade required to rate users.', true);
      } else {
        showRateMsg(err?.message || 'Failed to submit rating', true);
      }
    } finally {
      submitRatingBtn.disabled = false;
    }
  });
}

// Wire the inline upgrade button to perform an upgrade (same UX as upgradeBtn)
if (upgradeInlineBtn) {
  upgradeInlineBtn.addEventListener('click', async () => {
    try {
      if (!confirm('Upgrade to a paid account?')) return;
      await fetchWithTimeout('users/me/upgrade', { method:'PUT' }, 8000);
      alert('Upgraded successfully!');
      currentUserTier = 'paid';
      // reload profile so rate form appears if viewing someone else
      await loadProfile();
    } catch (err) {
      alert(err?.message || 'Upgrade failed');
    }
  });
}

/* -------------------------------- Init -------------------------------- */
loadProfile();
</script>
</body>
</html>
